#!/usr/bin/env bash

# Bash based HTTP Web Server.

# Thanks to "You Suck At Programming" for the video.
# Got to learn many stuff regrading bash and coding.

# OG Author: Dave Eddy
# Author: shahil ahmed (sk)
# Date: August 7, 2025

VERSION='v1.0.0'

PORT=8080
ADDRESS=0.0.0.0
DIR='.'

read -d '' -r USAGE <<- EOF
Usage: bash-web-server [-p port] [-b addr] [-d dir]

An HTTP server in Pure Bash.

Options
  -b <addr>  Address to bind to, defaults to 0.0.0.0.
  -d <dir>   Directory to serve, defaults to your current directory.
  -h         Print this message and exit.
  -p <port>  Port to bind to, defaults to 8080.
  -v         Print the version number and exit.
EOF

fatal() {
    echo '[fatal]' "$@" >&2
    exit
}

urldecode() {
    # Usage: urldecode "string"
    : "${1//+/ }"
    printf '%b\n' "${_//%/\\x}"
}

urlencode() {
    # Usage: urlencode "string"
    local LC_ALL=C
    for (( i = 0; i < ${#1}; i++ )); do
        : "${1:i:1}"
        case "$_" in
            [a-zA-Z0-9.~_-])
                printf '%s' "$_"
            ;;

            *)
                printf '%%%02X' "'$_"
            ;;
        esac
    done
    printf '\n'
}

html-encode() {
    local s=$1

    # doing basic html encodeing by replacing the character with bash equilent
    s=${s//&/\&amp; }
    s=${s//</\&lt;}
    s=${s//>/\&gt; }
    s=${s//\"\\&quot;}
    s=${s//\'/\&apos;}

    echo "$s"
}

list-directory() {
    local d=$1

    shopt -s nullglob dotglob

    echo '<h1>Directory Listing</h1>'
    echo "<h2>Directory: $(html-encode "$d")</h2>"
    echo '<hr>'
    echo '<ul>'
    for f in .. "$d"/*; do
        f=${f##*/}
        printf '<li><a href="%s">%s</a></li>\n' $(urlencode "$f") $(html-encode "$f")
    done
    echo '</ul>'
    echo '</hr>'
}

mime-type() {
    local f=$1
    local bname=${f##*/}
    local ext=${bname##*.}
    [[ $bname == "$ext" ]] && ext=

    case "$ext" in
     html|htm) echo 'text/html';;
     jpeg|jpg) echo 'image/jpeg';;
          png) echo 'image/png';;
          txt) echo 'text/plain';;
          css) echo 'text/css';;
           js) echo 'text/javascript';;
         json) echo 'application/json';;
            *) echo 'application/octet-stream'
    esac
}

normalize-path() {
    local path=/$1

    IFS='/' read -r -a parts <<< "$path"

    local part
    local -a out=()
    for part in "${parts[@]}"; do
        case $part in
        '') ;; # ignore empty dir (multiple /)
        '.') ;; # ignore current dir
        '..') unset 'out[-1]' 2>/dev/null;;
        *) out+=("$part");;
        esac
    done

    local string
    string=$(IFS=/; echo "${out[*]}")
    echo "/$string"
}


parse-request() {

    declare -gA REQ_INFO=()
    declare -gA REQ_HEADERS=()

    local state='status'
    local line

    while read -r line; do
        line=${line%$'\r'}

        case "$state" in
                'status')
                        # parse the status line
                        # "GET /foo.txt HTTP/1.1"
                        local method path version
                        read -r method path version <<< "$line"
                        REQ_INFO[method]=$method
                        REQ_INFO[path]=$path
                        REQ_INFO[version]=$version
                        state='headers'
                        ;;
                'headers')
                        # parse the headers
                        if [[ -z $line ]]; then
                            # doesnt support body parsing
                            break
                        fi
                        local key value
                        IFS=: read -r key value <<< $line
                        key=${key,,}
                        value=${value# *}
                        REQ_HEADERS[$key]=$value
                        ;;
                'body')
                        fatal 'body parsing not supported'
                        ;;
        esac
    done
}

process-request() {
    local fd=$1
    parse-request <&"$fd"

    #validate the request
    [[ ${REQ_INFO[version]} == 'HTTP/1.1' ]] || fatal 'Unsupported HTTP version'
    [[ ${REQ_INFO[method]} == 'GET' ]] || fatal 'Unsupported HTTP method'
    [[ ${REQ_INFO[path]} == /* ]] || fatal 'invalid path'

    echo "$ip ${REQ_INFO[method]} ${REQ_INFO[path]}"

    # if we are here, we should reply to the caller
    # /foo%20bar.txt?query=something
    local path=${REQ_INFO[path]}

    # "./.foo%20bar.txt?query=whatever"
    path=${path:1}

    # "././foo%20bar.txt"
    local query
    IFS='?' read -r path query <<< "$path"

    # "././foo bar.txt"
    path=$(urldecode "$path")

    # "././foo bar.txt"
    path=$(normalize-path "$path")

    # "foo bar.txt"
    path=${path:1}

    # handle empty path(root path)
    path=${path:-.}
    # path=${path:-'index.html'}

    # try to serve an index page
    local totry=(
        "$path"
        "$path/index.html"
        "$path/index.htm"
    )
    local try file

    for try in "${totry[@]}"; do
        if [[ -f $try ]]; then
            file=$try
            break
        fi
    done

    if [[ -n $file ]]; then
        # a static file was found
        local mime
        mime=$(mime-type "$file")

        printf 'HTTP/1.1 200 OK\r\n' >&"$fd"
        printf 'Content-Type: %s\r\n' $mime >&"$fd"
        printf '\r\n' >&"$fd"
        cat "$file" >&"$fd"
    elif [[ -d $path ]]; then
        # try directory listing
        printf 'HTTP/1.1 200 OK\r\n' >&"$fd"
        printf 'Content-Type: text/html\r\n' >&"$fd"
        printf '\r\n' >&"$fd"
        list-directory "$path" >&"$fd"
    else
        # nothing was found
        printf 'HTTP/1.1 404 Not Found\r\n' >&"$fd"
        printf '\r'
    fi

}

main() {

    enable accept || fatal 'failed to load accept'

    local OPTIND opt 
    while getopts 'b:hp:h:v' opt; do
        case "$opt" in 
            b) ADDRESS=$OPTARG ;;
            p) PORT=$OPTARG ;;
            d) DIR=$OPTARG ;;
            h) echo "$USAGE" && exit 0;;
			v) echo "$VERSION" && exit 0;;
            *) fatal "bad option";;
        esac
    done

    local fd ip
    echo "Listing on https://$ADDRESS:$PORT"

    cd "$DIR" || fatal "faild to move to $DIR"
    echo "serving out of $DIR"

    while true;
        do
            accept -b "$ADDRESS" -v fd -r ip "$PORT" || fatal 'failed to read socket'
            process-request "$fd" &
            exec {fd}>&-
        done
    
}

main "$@"
